# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from ccline import ccline_pb2 as ccline_dot_ccline__pb2


class NodeStub(object):
    """All nodes must implement this service.
    TODO - should split out Goose from internal calls.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Goose = channel.unary_unary(
                '/ccline.Node/Goose',
                request_serializer=ccline_dot_ccline__pb2.GooseRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.GooseReply.FromString,
                )
        self.Record = channel.unary_unary(
                '/ccline.Node/Record',
                request_serializer=ccline_dot_ccline__pb2.RecordRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.RecordReply.FromString,
                )
        self.LiveSample = channel.unary_unary(
                '/ccline.Node/LiveSample',
                request_serializer=ccline_dot_ccline__pb2.LiveSampleRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.LiveSampleReply.FromString,
                )
        self.Shutdown = channel.unary_unary(
                '/ccline.Node/Shutdown',
                request_serializer=ccline_dot_ccline__pb2.ShutdownRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.ShutdownReply.FromString,
                )


class NodeServicer(object):
    """All nodes must implement this service.
    TODO - should split out Goose from internal calls.
    """

    def Goose(self, request, context):
        """Respond with the address of the current cooridinator.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Record(self, request, context):
        """Internal recording operation for this node.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def LiveSample(self, request, context):
        """Synchronous capture and reply from this node.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Shutdown(self, request, context):
        """Tries to shut down this node. Use the coordinator ShutdownAll to power off
        the entire cluster. There may be network or data-related reasons to shut
        nodes off in a specific sequence.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_NodeServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Goose': grpc.unary_unary_rpc_method_handler(
                    servicer.Goose,
                    request_deserializer=ccline_dot_ccline__pb2.GooseRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.GooseReply.SerializeToString,
            ),
            'Record': grpc.unary_unary_rpc_method_handler(
                    servicer.Record,
                    request_deserializer=ccline_dot_ccline__pb2.RecordRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.RecordReply.SerializeToString,
            ),
            'LiveSample': grpc.unary_unary_rpc_method_handler(
                    servicer.LiveSample,
                    request_deserializer=ccline_dot_ccline__pb2.LiveSampleRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.LiveSampleReply.SerializeToString,
            ),
            'Shutdown': grpc.unary_unary_rpc_method_handler(
                    servicer.Shutdown,
                    request_deserializer=ccline_dot_ccline__pb2.ShutdownRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.ShutdownReply.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ccline.Node', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Node(object):
    """All nodes must implement this service.
    TODO - should split out Goose from internal calls.
    """

    @staticmethod
    def Goose(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Node/Goose',
            ccline_dot_ccline__pb2.GooseRequest.SerializeToString,
            ccline_dot_ccline__pb2.GooseReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Record(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Node/Record',
            ccline_dot_ccline__pb2.RecordRequest.SerializeToString,
            ccline_dot_ccline__pb2.RecordReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def LiveSample(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Node/LiveSample',
            ccline_dot_ccline__pb2.LiveSampleRequest.SerializeToString,
            ccline_dot_ccline__pb2.LiveSampleReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Shutdown(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Node/Shutdown',
            ccline_dot_ccline__pb2.ShutdownRequest.SerializeToString,
            ccline_dot_ccline__pb2.ShutdownReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class CoordinatorStub(object):
    """An external client finds and uses the coordinator to collect complete and
    synchronized imagery and data. Most requests are routed through the
    coordinator rather than relying on the external client to retain state about
    all nodes.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.StartCollecting = channel.unary_unary(
                '/ccline.Coordinator/StartCollecting',
                request_serializer=ccline_dot_ccline__pb2.StartCollectingRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.StartCollectingReply.FromString,
                )
        self.StopAllCollects = channel.unary_unary(
                '/ccline.Coordinator/StopAllCollects',
                request_serializer=ccline_dot_ccline__pb2.StopAllCollectsRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.StopAllCollectsReply.FromString,
                )
        self.ShutdownCluster = channel.unary_unary(
                '/ccline.Coordinator/ShutdownCluster',
                request_serializer=ccline_dot_ccline__pb2.ShutdownClusterRequest.SerializeToString,
                response_deserializer=ccline_dot_ccline__pb2.ShutdownClusterReply.FromString,
                )


class CoordinatorServicer(object):
    """An external client finds and uses the coordinator to collect complete and
    synchronized imagery and data. Most requests are routed through the
    coordinator rather than relying on the external client to retain state about
    all nodes.
    """

    def StartCollecting(self, request, context):
        """The coordinator can accept collection-related commands.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StopAllCollects(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ShutdownCluster(self, request, context):
        """Sequenced shutdown for all nodes. There is no programmatic way to turn the
        cluster back on.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_CoordinatorServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'StartCollecting': grpc.unary_unary_rpc_method_handler(
                    servicer.StartCollecting,
                    request_deserializer=ccline_dot_ccline__pb2.StartCollectingRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.StartCollectingReply.SerializeToString,
            ),
            'StopAllCollects': grpc.unary_unary_rpc_method_handler(
                    servicer.StopAllCollects,
                    request_deserializer=ccline_dot_ccline__pb2.StopAllCollectsRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.StopAllCollectsReply.SerializeToString,
            ),
            'ShutdownCluster': grpc.unary_unary_rpc_method_handler(
                    servicer.ShutdownCluster,
                    request_deserializer=ccline_dot_ccline__pb2.ShutdownClusterRequest.FromString,
                    response_serializer=ccline_dot_ccline__pb2.ShutdownClusterReply.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ccline.Coordinator', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Coordinator(object):
    """An external client finds and uses the coordinator to collect complete and
    synchronized imagery and data. Most requests are routed through the
    coordinator rather than relying on the external client to retain state about
    all nodes.
    """

    @staticmethod
    def StartCollecting(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Coordinator/StartCollecting',
            ccline_dot_ccline__pb2.StartCollectingRequest.SerializeToString,
            ccline_dot_ccline__pb2.StartCollectingReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StopAllCollects(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Coordinator/StopAllCollects',
            ccline_dot_ccline__pb2.StopAllCollectsRequest.SerializeToString,
            ccline_dot_ccline__pb2.StopAllCollectsReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ShutdownCluster(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/ccline.Coordinator/ShutdownCluster',
            ccline_dot_ccline__pb2.ShutdownClusterRequest.SerializeToString,
            ccline_dot_ccline__pb2.ShutdownClusterReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
